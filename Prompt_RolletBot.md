أنت مساعد/محرّر برمجي متمرس. مهمتك: استكمال وبناء مشروع بوت تليجرام متكامل طبقًا للمواصفات التفصيلية التالية، مع **مراجعة وتصحيح ودمج الملفات المصدرية الموجودة لدى العميل** (المستخدم قد بدأ بكتابة بعض ملفات البوت — افحصها، عدّلها لتتوافق مع التصميم العام، وأدمجها ضمن البنية النهائية).

اللغة والتقنيات الافتراضية (قابلة للتغيير فقط إذا طُلب صراحة):
- Python 3.11+، aiogram 3.x (مُعدّ للعمل عبر polling / getUpdates — لا webhooks).
- PostgreSQL كقاعدة بيانات علائقية (SQLAlchemy + asyncpg + Alembic للميراشنز).
- Redis (لتخزين الجلسات المؤقتة، قائمة المهام، rate-limiting، و\Queue\ workers).
- واجهة إدارة بسيطة: FastAPI (اختياري) + لوحة إدارية عبر أوامر /admin في البوت. نفّذ كليهما إن أمكن.
- بنية المشروع: OOP صارم، طبقات واضحة (handlers, services, repositories, models, schemas, core, utils).
- أسلوب برمجي يراعي SOLID، Dependency Injection، واستخدام async/await.

المتطلبات الخاصة التي يجب الالتزام بها حرفيًا:
1. الدفع: **دفع بنجوم تيليجرام**.
   - نفذ طبقة PaymentProvider مجردة مع تنفيذ افتراضي متكامل لآليون الدفع عبر واجهات Telegram (Invoices) لتوفير "شراء نجوم" وخصمها عند التصويت بنجوم.
   - إن كانت تكاملات API الحقيقية لنجوم تيليجرام تتطلب إعدادات خاصة، ضَع TODO واضح مع شرح أين ولماذا يحتاج مالك البوت مفاتيح/إعدادات حقيقية. في بيئة التطوير استخدم dummy provider يُكمل التدفق (تنشيط الحالة paid) لاختبارات الـE2E.
   - سجّل كل فاتورة/رمز (invoice_code) في جدول payments مع الحالة، الربط بالمسابقة أو المستخدم، والـmetadata.

2. التشغيل عبر Polling (getUpdates)
   - قُم ببناء البوت ليعمل باستخدام long polling (aiogram polling), مع إعدادات قابلة للتعديل (timeout, workers, concurrency).
   - أضف آلية لتشغيل عدة مثيلات للـbot workers (horizontal scaling) مع coordination عبر Redis (مثلاً: lease lock لمنع معالجة نفس التحديث مرتين).

3. قابلية التحمّل والاعتمادية
   - هدف: خدمة آلاف المستخدمين و10s — 100s مسابقات تعمل في وقت واحد.
   - استخدم:
     · connection pooling لPostgres (asyncpg pool).
     · pagination وindexes على الجداول التي ستنمو كثيرًا (participants, votes, lotteries).
     · العمليات الثقيلة (مثل سحب الفائزين العشوائيين، حساب إحصاءات ضخمة، إنشاء تقارير) تُنفذ في background workers (RQ/Celery/fast-worker) متصل بـRedis.
     · caching حيث يناسب (مثل: حالة الاشتراك في القناة للتحققات المتكررة) مع TTL قابل للتعديل.
   - صمّم نماذج DB بحيث تدعم sharding/partitioning مستقبليًا إذا لزم.

4. مراجعة ودمج الملفات الموجودة
   - المحرر يجب أن:
     · يستقبل/يفحص الملفات الحالية (repo link أو أرشيف)، يشغّل linters (ruff/flake8) وmypy إن وُجدت تلميحات نوعية، ويُدرج التعديلات كـ commits مقترحين.
     · يكتب تقرير مراجعة (CHANGELOG أو REVIEW.md) يوضح ما تم إصلاحه/تغييره ولماذا.
     · يدمج الأكواد الصالحة في البنية النهائية ويحفظ الأكواد غير المكتملة كـ TODOs أو branches.

الوظائف الأساسية — يجب أن تُنفَّذ وتعمل end-to-end كمثال عملي:
1) تفعيل / الاشتراك الإجباري
- إعداد config عام قابل للتعديل عبر /admin أو واجهة FastAPI: flag للاشتراك_الإجباري + chat_id لقناة الاشتراك.
- عند /start:
  · إن كانت الخاصية مفعلة: تحقّق حالة المستخدم في قناة الاشتراك عبر getChatMember.
  · إن لم يكن مشتركًا: أظهر رسالة بالعربية تحتوي على زرين:
    - "اضغط للاشتراك" → External URL button يفتح القناة.
    - "لقد اشتركت" → يعيد التحقق فورًا.
  · بعد التحقق الناجح: سجّل المستخدم في جدول users (أو حدث حالته) وعرِض لوحة الأزرار الرئيسية.

2) لوحة الأزرار الرئيسية (بعد التحقق)
- أزرار (InlineKeyboard / Keyboard) تظهر للمستخدم بالعربية:
  1. "قسم الروليت"
  2. "قسم مسابقات التصويت"
  3. "مسابقة 'يستحق'"
  4. "قسم مسابقة الأسئلة"
  5. "إدارة المجموعات/القنوات المضافة"
  6. "إدارة الاشتراك"
  7. "إدارة سحوباتي ومسابقاتي"
  8. "كسب النقاط"

3) قسم الروليت — تنفيذ كامل كقالب وظيفي
- إنشاء روليت: اختيار القناة/المجموعة (قائمة المضافات أو إضافة جديدة مع فحص getChat + التأكد أن البوت مشرف).
- شروط السحب: تنفيذ كل الشروط الممكنة (قناة شرط، مجموعة شرط، رمز تصويت، تعليق على منشور، اشتراك في روليت آخر).
- كليشة السحب مع دعم تنسيقات Telegram.
- تخصيص الإعدادات (نوع المستخدمين، تعطيل/تفعيل اشتراط الاشتراك، منع الوهمي، استبعاد المغادرين).
- عند التأكيد: توليد code فريد (base62/UUID short)، نشر الكليشة في القناة مع 3 أزرار شفافة: عدد المشتركين، مشاركة السحب، الاشتراك في السحب.
- آلية الاشتراك في السحب:
  · التحقق من الاشتراك (مع cache TTL).
  · إعادة توجيه المستخدم للخاص → إجراء anti-bot challenge (configurable: simple math, timed button, أو CAPTCHA-like).
  · تحقق الشروط الإضافية.
  · تسجيل المشارك في lottery_participants مع metadata.

4) مسابقات التصويت و"يستحق" و"نجوم"
- تنفيذ نظام التصويت العادي والنجوم (stars) والنسخة المزدوجة.
- المتسابقون يسجلون عبر الخاص → ينشئ البوت message في القناة لكل متسابق مع زر يظهر عدد المصوتين ورمز التصويت.
- عند الضغط على زر التصويت: تحقق اشتراك → توجيه للخاص → اختبار منع الوهمي إن مفعل → إذا تطلب تصويت نجوم: افتح واجهة شراء نجوم (Telegram Invoice flow) أو استخدم رصيد النجوم من الحساب.
- سجّل كل تصويت في جدول votes مع دعم stars count وnormal votes.
- عند إنهاء المسابقات: حساب النجوم، إنشاء فاتورة إجمالية إن لزم (payments table) مع إمكانية تحويلها للمالك.

5) مسابقة الأسئلة (Quiz)
- نشر أسئلة بالتتابع (في القناة أو المجموعة)، أول من يرد بالإجابة الصحيحة يحصل على نقطة.
- مديرة المسابقة لديها أزرار "إيقاف مؤقت" و"إعلان الفائزين".
- سجل إجابات، نقاط، وقدم ملخصًا عند النهاية.

6) إدارة المجموعات/القنوات والمستخدمين
- CRUD لربط/فك الربط مع تحقق (getChat, ensure bot is admin).
- واجهة عرض السحوبات/المسابقات الخاصة بكل مستخدم، إمكانية تعديل/إلغاء وسحب تقارير المشاركين.

7) نظام النقاط والإحالة
- referral link: https://t.me/<BOT_USERNAME>?start=<user_id>
- نقاط تُمنح حسب إعداد الأدمن، قابلة لاستبدالها بدفع اشتراك أو تحويل لنجوم.
- واجهة إدارة قيم نقاط الإحالة في /admin أو FastAPI.

قاعدة البيانات — جداول أساسية (يجب إنشاؤها كميراشنز عبر Alembic):
- users, settings, channels, user_channels, lotteries, lottery_participants, contests, contest_entries, votes, questions, quiz_runs, payments, audit_logs.
- عيّن مؤشرات (indexes) على الحقول ذات الاستعلام المتكرر: lottery_id, user_id, status, created_at.

خريطة الخدمات (Service classes) المطلوبة:
- SubscriptionService, LotteryService, VoteService, ContestService, QuizService, PaymentService (TelegramStarsPaymentProvider), ReferralService, ChannelService, AdminService, AuditService.
- كل Service يتواصل عبر Repositories (UsersRepo, LotteryRepo, VoteRepo, PaymentRepo...).

مواصفات التشغيل والنشر:
- Dockerfile للبوت، docker-compose.yml يشغّل: bot(s), postgres, redis, worker(s), (optional: pgadmin, fastapi).
- إعدادات بيئية في .env.example متضمنة: TELEGRAM_TOKEN, DATABASE_URL, REDIS_URL, TELEGRAM_PAYMENTS_TOKEN, BOT_USERNAME, POLLING_WORKERS, CAPTCHAS_CONFIG, etc.
- سكربت init (Makefile أو scripts/init.sh) يقوم بإنشاء DB، تشغيل alembic upgrade, وإضافة seeds.

اختبارات:
- pytest مع تغطية لحالات: /start واشتراك إجباري (مشترك/غير مشترك)، إنشاء روليت، الاشتراك في السحب (مع/بدون شروط)، منع الوهمي، التصويت بنجوم وحساب النجوم، إنهاء مسابقة الأسئلة.
- fixtures للفوكوس على DB test (docker-compose test postgres أو sqlite-memory حسب السيناريو).

مخرجات متوقعة من المحرر فورًا (Deliverables initial):
1. scaffolding المشروع (شجرة ملفات) + ملفات إعدادات أساسية.
2. مثال migration لإنشاء الجداول الأساسية.
3. كود يعمل end-to-end لميزة أساسية: **تفعيل الاشتراك الإجباري + /start flow + حفظ user + عرض لوحة الأزرار الرئيسية** (يجب أن يعمل محليًا عبر docker-compose باستخدام polling).
4. نموذج PaymentProvider مع dummy implementation و TODO واضح لدمج Telegram Stars الحقيقية + مثال إدخال بيانات تجريبية.
5. تقرير مراجعة (REVIEW.md) يبين تعديلات/اقتراحات على الملفات الموجودة التي وفّرها العميل — مع قائمة ملفات تحتاج اندماج أو إعادة كتابة.
6. README يشرح خطوة بخطوة: تشغيل محليًا، تشغيل tests، كيفية رفع migrations، وكيفية تزويد المفاتيح الحقيقية لTelegram Payments.
7. أمثلة رسائل i18n بالعربية (ملف واحد messages.ar.json أو yaml يحتوي كل الرسائل المستخدمة).

متطلبات هندسية وعملياتية إضافية:
- سجّل كل أحداث مهمة في audit_logs (إنشاء سحب، سحب فائزين، مدفوعات).
- عيّن rate-limiting على الواجهات الحساسة (مثل: endpoints لبدء سحب، توليد فاتورة).
- ضع آليات soft-delete للقنوات/السحوبات قبل الحذف الفعلي.
- أضف healthchecks و metrics بسيطة (prometheus metrics endpoints إن أمكن) لقياس queue depth، db connections، processing latency.
- اكتب TODOs واضحة لأي جزء يعتمد على مفاتيح خارجية أو إعدادات يدوية.

ملاحظات للمحرر عند استلام الملفات الحالية من العميل:
- قبل البدء: قم بفحص سريع للـrepo/الملفات، شغّل linters وpytest إن أمكن.
- أنشئ branch باسم feature/integrate-existing-code ثم ابدأ الدمج مع commits منطقية.
- سجل كل تعديل في REVIEW.md مع تعليمات التشغيل.

نهاية الطلب:
- ابدأ الآن بإنشاء scaffolding وتنفيذ الـdeliverables الأولية (مذكورة أعلاه). أظهِر ملفات migration، كود الاشتراك الإجباري و /start flow يعملان عبر polling، وملف README. ضمّن تقرير مراجعة للملفات الموجودة واذكر الخطوات التالية لدمج بقية الموديولات (روليت، تصويت، نجوم، مسابقات الأسئلة).